
SQL (Structured Query Language)


DB Browser for SQLite
https://sqlitebrowser.org


import sqlite3


Простейшая заготовка для свзяи с базой данных saper.db.
Если БД существует -- файл открывается.
Если БД не существует -- файл создается.

import sqlite3 as sq
 
con = sq.connect("saper.db")
cur = con.cursor()
 
cur.execute("""
""")
 
con.close()


connect("path/to/database.db"). У метода connect() есть и другие параметры, определяющие свойства подключения. 

Расширения файлов:
*.db, *.db3, *.sqlite и *.sqlite3


сursor() создает объект курсор
Курсор — поименованная область памяти, содержащая результирующий набор select запроса. 
Второе определение — это механизм обработки результирующего набора select запроса.
https://ru.wikipedia.org/wiki/%D0%9A%D1%83%D1%80%D1%81%D0%BE%D1%80_(%D0%B1%D0%B0%D0%B7%D1%8B_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85)

execute(...) выполняет SQL запрос. Аргумент -- строка запроса; возможен еще список или словарь параметров.
executmany(...)
executescript(...)

Обязательно нужно закрывать соединения с БД!
Или, еще лучше, оборачивать с помощью менеджера контекста with ... as.
Это гарантирует, что критические функции выполнятся в любом случае. 

with sq.connect("saper.db") as con:
    cur = con.cursor()
    cur.execute("""
    """)


Типы
NULL 
INTEGER – (занимает от 1 до 8 байт);
REAL – вещественный тип (8 байт в формате IEEE);
TEXT – строковый тип (в кодировке данных базы, обычно UTF-8);
BLOB (двоичные данные, хранятся «как есть», например, для небольших изображений).

В мануале пишут, что типы имен полей можно не указывать, спасибо flexible typing
Column Datatype	  Types Allowed In That Column
INTEGER	          INTEGER, REAL, TEXT, BLOB
REAL	          REAL, TEXT, BLOB
TEXT	          TEXT, BLOB
BLOB	          INTEGER, REAL, TEXT, BLOB

Без типизации
cur.execute("CREATE TABLE users(name, sex, old, score)")


С типизацией SQL-запрос
cur.execute("""CREATE TABLE users (
    name TEXT,
    sex INTEGER,
    old INTEGER,
    score INTEGER
)""")

!!!!!
Таблица создастся, но при повторной компиляции выдаст ошибку, что она уже создана, поэтому лучще добавить условие
CREATE TABLE IF NOT EXISTS users ( ...)

!!!!!
Скрытое поле для каждой записи, индивидуальный идентификатор
SELECT rowid, * FROM users
или создать поле с ограничителями PRIMARY KEY AUTOINCREMENT
user_id INTEGER PRIMARY KEY AUTOINCREMENT


==== Удаление таблицы
cur.execute("DROP TABLE users")
cur.execute("DROP TABLE IF EXISTS users")

=== ОГРАНИЧИТЕЛИ
NOT NULL
DEFAULT 1

=== ФОРМАТ INSERT
INSERT INTO <table_name> VALUES (<value1>, <value2>, …)
INSERT INTO <table_name> (<column_name1>, <column_name2>, ...) VALUES (<value1>, <value2>, …)
В первом случае данные перечисляются по порядку, так как не задан порядок в круглях скобках (полях).
Примеры
INSERT INTO users VALUES('Михаил', 1, 19, 1000)
INSERT INTO users (name, old, score) VALUES('Алексей', 18, 1000)  -- поле sex пропущено, 
  оно будет добавлено автоматически NULL по умолчанию DEFAULT


=== ФОРМАТ INSERT
SELECT col1, col2, … FROM <table_name>
ELECT col1, col2, … FROM <table_name> WHERE <условие>
Примеры
SELECT * FROM users
SELECT name, score FROM users
SELECT * FROM users WHERE score < 100
SELECT * FROM users WHERE old > 20 AND score < 1000
SELECT * FROM users WHERE old IN(19, 32) AND score < 1000
SELECT * FROM users WHERE old IN(19, 32) AND score > 300 OR sex = 1  -- равносильно (IN(19, 32) AND score > 300) OR sex = 1
SELECT * FROM users WHERE (old IN(19, 32) OR sex = 1) AND score > 300

Операторы не действуют друг за другом.
Весь список сверху выдаст только результат от последнего селекта.

Операторы сравнения:
= или ==, >, <, >=, <=, !=, BETWEEN

Ключевые слова для составных условий
AND, OR, NOT, IN, NOT IN

Приоритет операций (от сильного к слабому): NOT OR AND

== Сортировка ORDER BY

SELECT * FROM users WHERE old > 20 AND score < 1000 
ORDER BY old

или аналогично по возрастанию
ORDER BY old ASC

по убыванию
ORDER BY old DESC


=== LIMIT Ограничение выборки 
LIMIT <max> [OFFSET offset]
LIMIT <offset, max>

SELECT * FROM users WHERE score > 100 ORDER BY score DESC LIMIT 5
SELECT * FROM users WHERE score > 100 ORDER BY score DESC LIMIT 5 OFFSET 2   -- пропускаем первые две записи
SELECT * FROM users WHERE score > 100 ORDER BY score DESC LIMIT 2, 5         -- то же самое


=== fetchall()

fetchall() - резльтат отбора SQL-запроса, выдает список кортежей. Можеь занять много памяти.

result = cur.fetchall()
print(result)

или так, обрабатывая одну строчку и экономя память
for result in cur:
    print(result)

fetchmany(n) -- список дляиной не более n
fetchone() -- возвращает первую запись














